#Reserved registers:
#GR0 : input
#GR1 : result
#GR2 : temp shift register
#GR3 : dot shift amount
#GR4 : final result
#GR5 : isnegative
 
start: RC 0,0	#Read input to GR0
LOAD$ 3,12
STORE 3,&shift

#Loop to beginning until input is a valid character
if 0 = $255
	JMP$ 0,&start
endif

if 0 = $44
    LOAD$ 5,1
    JMP$ 0,&start
endif

if 0 = $41
    JMP$ 0,&dotfirst
endif

if 0 = $47
    if 5 = $1
        STORE 1,&result
        LOAD$ 1,0
        SUB 1,&result
    endif
    JMP$ 0,&done
endif

if 0 < $16		#If numerical
    LSL$ 0,16
	STORE 0,&input
    LSL$ 1,4
    ADD 1,&input
endif
JMP$ 0,&start

#___DOT___

dotfirst: STORE 1,&heltal
LOAD$ 1,0
dot: RC 0,0	#Read input to GR0

#Loop to beginning until input is a valid character
if 0 = $255
	JMP$ 0,&dot
endif

if 0 = $47
    if 5 = $1
        LOAD$ 6,0
        SUB 6,&heltal
        STORE 6,&heltal

        STORE 1,&dec
        LOAD$ 6,0
        SUB 6,&dec
        STORE 6,&dec
        LOAD 1,&dec
    endif
    
    ADD 1,&heltal
    JMP$ 0,&done
endif

if 0 < $16		#If numerical
    LSL 0,&shift
	STORE 0,&input
    ADD 1,&input
    SUB$ 3,4
    STORE 3,&shift
endif
JMP$ 0,&dot

done: STORE 1,&result
LOAD 4,&result



##########################
#    display result      #
##########################

load 0,&result # 1.5 in fixed point
load$ 1,100
load$ 2,&start
jmp$ 0,&printnum

# Save number to gr0, tileaddr to gr1 and return addr to gr2 before running

# GR usage:
# 0-Loop Counter
# 1-Or map
# 2-tileaddr
# 3-number to display
# 4-6 Unused
# 7-Loop counter to move numbers
sli 0

# Load input data
printnum: store 0,&number
store 1,&startat
store 2,&returnaddr

# Setup
load$ 0,8 #loop counter
load$ 1,4026531840 #or-map
load 2,&startat # Tile addr

load 3,&number
if 3<$0
    # Display minus sign and move location one place
    load$ 3,44 # minus tile
    storep~ 3,&startat
    add$ 2,1
    store 2,&startat


    # Get abs of number
    load$ 4,0
    sub 4,&number
    store 4,&number
end if

# Run for all 8 hex digits
while 0>$1
    load 3,&number # Set gr3 to &number

    # Filter out current nibble
    store 1,&bitmap
    and 3,&bitmap
    lsr$ 1,4 # Move bitmap

    # Move resulting number over to end of gr3
    store 0,&loopvar1
    load 7,&loopvar1
    while 7>$2
        lsr$ 3,4
        sub$ 7,1
    end while

    # Store final number to display
    storep~ 3,&startat

    # Prepare next loop
    sub$ 0,1
    add$ 2,1
    store 2,&startat

    # Place a + sign where the decimal point is
    if 0=$4
	    load$ 3,41 # dot tile
        storep~ 3,&startat
        add$ 2,1
        store 2,&startat
    end if
end while


# Jump to return adress specified by caller
jmp 0,&returnaddr
number: sli 0
bitmap: sli 0
loopvar1: sli 0
loopvar2: sli 0
startat: sli 40 # Where to start placing numbers
returnaddr: sli 0
#end: jmp 0,&returnaddr

#Empty rows for variables
input: SLI 0
heltal: SLI 0
shift: SLI 0
result: SLI 0
dec: SLI 0
