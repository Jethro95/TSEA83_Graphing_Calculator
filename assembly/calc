#REGISTER USAGE:
#GR0 : start address
#GR1 : length of 'array'
#GR2 : input (from text2hex)
#GR3 : current address
#GR4 : op vector address
#GR5 : temp register

#resets program for new calculation loop
ultrareset: LOAD$ 0,0
STORE 0,&input
STORE 0,&heltal
STORE 0,&shift
STORE 0,&result
STORE 0,&opaddr
STORE 0,&curaddr
STORE 0,&loopcounter

include text2hex

#if enter, perform calculation and show result
if 2 = $42
    JMP$ 0,&test
endif

#if input is operator
if 2 > $42
    if 2 < $47
        #Update op vector
        LOAD$ 4,&op
	    ADD 4,&loopcounter
        STORE 4,&opaddr
        LOAD$ 5,1
        STORE~ 5,&opaddr
        JMP$ 0,&isop
    endif
endif

#insert 0 in op vector if not operator
#skip this if operator
LOAD$ 4,&op
ADD 4,&loopcounter
STORE 4,&opaddr
LOAD$ 5,0
STORE~ 5,&opaddr

#update data stack
isop: LOAD$ 3,&memstart
ADD 3,&loopcounter
STORE 3,&curaddr
STORE~ 2,&curaddr
LOAD 1,&loopcounter
ADD$ 1,1
STORE 1,&loopcounter

#display input
#30 rows, 40 columns
#save number to GR0, tileaddr to GR1, return address to GR2 for print_num
#GR0 is already number
#LOAD 1,&tileaddr
#LOAD$ 2,&continue
#JMP$ 0,&printnum

#continue here
#continue: ADD$ 1,40
#STORE 1,&tileaddr
continue: JMP$ 0,&reset     #accept new input

#======================
#   TESTS
#======================


test: load$ 0,&memstart # start of input
load$ 1,&op
load 2,&loopcounter
load$ 3,&getbackhere
jmp$ 0,&evaluate

getbackhere: LOAD 1,&tileaddr # We want the number to be displayed at tileaddr
# GR0 is already result
load$ 2,&end
jmp$ 0,&printnum

include reverse_polish
include print_num

end: LOAD 1,&tileaddr 
ADD$ 1,40
STORE 1,&tileaddr
JMP$ 0,&ultrareset

opaddr: SLI 0
curaddr: SLI 0
loopcounter: SLI 0
tileaddr: SLI 0
memstart: SLI 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
op: sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
