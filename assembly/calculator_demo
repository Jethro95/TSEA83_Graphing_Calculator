
#======================
#   TESTS
#======================

# Demo usage of script
load$ 0,&data # start of input
load$ 1,3 # TODO: Change to 3 if other tests
load$ 2,&getbackhere
jmp$ 0,&evaluate
getbackhere: load$ 1,10 # We want the number to be displayed at tileaddr 10-18
# GR0 is already result
load$ 2,&end
jmp$ 0,&printnum


end:jmp$ 0,&end

# Test -7.62(slightly wrong)*2=-15.24 
data: sli 4294469222
sli 131072
sli 45 # mult

# Test 3-1=2
#data: sli 1
#sli 3
#sli 44 # Minus

# Test 2*2=4
#data: sli 131072 #2.0
#sli 131072 #2.0
#sli 45 # Mult

# Test 5 1 2 + 4 * + 3 âˆ’ = 14
# (the one from https://en.wikipedia.org/wiki/Reverse_Polish_notation)

#==============================

# HOW TO USE:
# Save start location of input to gr0, number of input values to gr1 and return to gr2
# Jump to &evaluate
# Result will be put in gr0. See below for a list of modified GRx's
# The routine was unsuccesful if Gr1 > 0 after running it.

# GR usage (after parsing arguments):
# 0-addr to top of stack
# 1-stack size
# 2-Next input token
# 4-tmp value storage
# 5-1 if success, 2 if error

#------------------------------

# Start of code

# Load input data
evaluate: store 0,&nextInputLocation
store 1,&inputcount
store 2,&returnaddr

# Setup
load$ 1,0 # Set stack size to 0
load$ 0,&stackstart # Initialize stack pointer
load 6,&inputcount

while 6>$1 #While there are input tokens left

    # Read the next token from input.
    load~ 2,&nextInputLocation
    # Increment nextInputLocation value; go to next input char
    # TODO: It's faster to just always use GR2 rather than
    #           Reading and writing from &nextInputLocation
    load 4,&nextInputLocation
    add$ 4,1
    store 4,&nextInputLocation


    # Check if token is a number or an operator and jump appropriately
    # TODO: Goto's aren't necessary if we implement OR's in sillescript.
    if 2=$43 # plus 
       jmp$ 0,&processOperator
    end if
    if 2=$44 # Minus
       jmp$ 0,&processOperator
    end if
    if 2=$45 # Mult
       jmp$ 0,&processOperator
    end if;
    #Not an operator...
    jmp$ 0,&processNumber

    #---------------------------------
    #     OPERATOR
    #---------------------------------
    #Note: each operator assumes two arguments
    processOperator:if 1<$2 # plus
        # Error, to few values to Evaluate
        load$ 0,0 # Put zero as result
	jmp 0,&returnaddr # Return
    end if

    # We seem to have enough to work with...

    # Load first value from stack to Gr7, stackpointer address to Gr0.
    store 0,&stackpointer
    load~ 7,&stackpointer

    # Find the second argument
    sub$ 0,1 # Decrement stack pointer
    sub$ 1,1 # Decrement stack size
    store 0,&stackpointer #Have &stackpointer point to arg number 2

    #Perform appropriate operation
    #TODO: Doesn't work with addf
    if 2=$43 # plus 
       addf~ 7,&stackpointer
    end if
    if 2=$44 # Minus

       # Minus takes order into consideration.
       # Unfortunately, the order the subf instruction does it in
       # Is the reverse of what we need.

       # To solve this, we need to store the second operand in GRx
       # and the first one in program memory.
       store 7,&tmp # Gr7 -> p_mem
       load~ 7,&stackpointer # p_mem (second operande) -> Gr7

       #Perform the operation, now with proper ordering
       subf 7,&tmp

    end if
    if 2=$45 # Mult
       multf~ 7,&stackpointer
    end if;

    # Save Gr7==result at the point in stack on which the second
    #    arg resided
    # TODO: ~ doesn't work for STORE.
    store~ 7,&stackpointer # Push the returned results to stack

    # Skip number processing
    jmp$ 0,&nextToken
    
    #-------------------------------
    #     NUMBER
    #-------------------------------
    #Not operator, push to stack
    processNumber:add$ 0,1
    add$ 1,1
    store 0,&stackpointer
    store~ 2,&stackpointer
    
    #-------------------------------

    nextToken:sub$ 6,1 # We have read one input token
end while

if 1=$1 #If there is only one value in the stack
    #That value is the result of the calculation.
    load~ 0,&stackpointer # gr0 is now the result
else
    # Error, user is stupid
    load$ 0,0 #Load 0 to result
end if

# Return to caller
jmp 0,&returnaddr

#=====================================
# Variables

# Stack
# Give us a couple of lines for the stack.
stackstart: sli 0
sli 0
sli 0
sli 0
sli 0
sli 0
sli 0

stackpointer: sli 0

#Used for some ALU tricks
tmp: sli 0

# Input data variables
nextInputLocation: sli 0
inputcount: sli 3
returnaddr: sli 0




# Demo usage of script

# Save number to gr0, tileaddr to gr1 and return addr to gr2 before running

# GR usage:
# 0-Loop Counter
# 1-Or map
# 2-tileaddr
# 3-number to display
# 4-6 Unused
# 7-Loop counter to move numbers
sli 0

# Load input data
printnum: store 0,&number
store 1,&startat
store 2,&returnaddrPrinter


# Make negative
#load$ 1,0
#sub 1,&number
#add$ 1,1
#store 1,&number



# Setup
load$ 0,8 #loop counter
load$ 1,4026531840 #or-map
load 2,&startat # Tile addr

load 3,&number
if 3<$0
    # Display minus sign and move location one place
    load$ 3,44 # minus tile
    storep~ 3,&startat
    add$ 2,1
    store 2,&startat


    # Get abs of number
    load 4,&number
    sub$ 4,1
    store 4,&number
    load$ 4,0
    sub 4,&number
    store 4,&number
end if

# Run for all 8 hex digits
while 0>$1
    load 3,&number # Set gr3 to &number

    # Filter out current nibble
    store 1,&bitmap
    and 3,&bitmap
    lsr$ 1,4 # Move bitmap

    # Move resulting number over to end of gr3
    store 0,&loopvar1
    load 7,&loopvar1
    while 7>$2
        lsr$ 3,4
        sub$ 7,1
    end while

    # Store final number to display
    storep~ 3,&startat

    # Prepare next loop
    sub$ 0,1
    add$ 2,1
    store 2,&startat

    # Place a + sign where the decimal point is
    if 0=$4
        load$ 3,41 # dot tile
        storep~ 3,&startat
        add$ 2,1
        store 2,&startat
    end if
end while


# Jump to return adress specified by caller
jmp 0,&returnaddrPrinter
number: sli 0
bitmap: sli 0
loopvar1: sli 0
loopvar2: sli 0
startat: sli 40 # Where to start placing numbers
returnaddrPrinter: sli 0
#end: jmp 0,&returnaddrPrinter
